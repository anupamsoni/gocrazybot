C51 COMPILER V8.08   SERIAL_LAB_WITH_ENCODER                                               06/04/2009 22:04:59 PAGE 1   


C51 COMPILER V8.08, COMPILATION OF MODULE SERIAL_LAB_WITH_ENCODER
OBJECT MODULE PLACED IN serial_lab with encoder.OBJ
COMPILER INVOKED BY: C:\SiLabs\MCU\IDEfiles\C51\BIN\C51.exe serial_lab with encoder.c DB OE

line level    source

   1          //-- This program makes the LED at P1.6 blink at different
   2          // speeds (SerialComm.C)
   3          //-- Uses Timer 3 and interrupts for the blinking frequency
   4          //-- Uses the external crystal oscillator 22.11845 MHz
   5          //-- Receives commands from PC to change the blinking speed
   6          //-- Timer 1 is used to generate Baud rate for UART0
   7          #include <c8051f020.h>
   8          #include <stdio.h>
   9          #include <stdlib.h>
  10          
  11          
  12          //--------------------------------------------------------------
  13          // 16-bit SFR Definitions for 'F02x
  14          //--------------------------------------------------------------
  15          sfr16 TMR3RL = 0x92; // Timer3 reload value
  16          sfr16 TMR3 = 0x94; // Timer3 counter
  17          //--------------------------------------------------------------// Global CONSTANTS
  18          //--------------------------------------------------------------
  19          #define BLINKCLK 2000000
  20          sbit LED = P1^6;
  21          sbit DIR = P1^0;
  22          unsigned char LED_count;
  23          unsigned char blink_speed;
  24          unsigned int received_byte;
  25          unsigned int sent_byte;
  26          unsigned int command;
  27          unsigned int message;
  28          unsigned int port5;
  29          unsigned int outBuffer[4];
  30          unsigned int RPM = 0x00;
  31          unsigned int pulses;
  32          unsigned int actual_speed;
  33          unsigned int Shaft_Speed        = 0x00;         //-- Stores actual speed
  34          unsigned int N;
  35          int encoder_count = 0x00;
  36          int time_in_sec;
  37          int i, count, random;
  38          int Tick_count = 0x00;
  39          
  40          
  41          unsigned short new_cmd_received; //-- set each time new
  42          unsigned short new_cmd_sent;
  43          int transmitFlag;
  44          int prevTransmitFlag;
  45          
  46          
  47          //-- function prototypes 
  48          void Init_Port(void);   //-- Configures the Crossbar and GPIO
  49                                                          // ports
  50          void Init_UART0(void);  //-- configure and initialize the UART0
  51                                                          // serial comm
  52          void Init_Timer3(unsigned int counts);
  53          void Init_Timer0(unsigned char reload0);
  54          void Timer0_ISR(void);
  55          void Timer3_ISR(void); //-- ISR for Timer 3
C51 COMPILER V8.08   SERIAL_LAB_WITH_ENCODER                                               06/04/2009 22:04:59 PAGE 2   

  56          void UART0_ISR(void); //-- ISR for UART0
  57          void Init_ADC0          (void);                 //-- Initialise the ADC0
  58          void ADC0_ISR       (void);
  59          void INT1_ISR           (void);
  60          
  61          //--------------------------------------------------------------
  62          
  63          #define LCD_DAT_PORT  P6                  // LCD is in 8 bit mode
  64          #define LCD_CTRL_PORT P7                  // 3 control pins on P7
  65          #define RS_MASK       0x01                // for assessing LCD_CTRL_PORT
  66          #define RW_MASK       0x02
  67          #define E_MASK        0x04
  68          
  69          //---------------------------------------------------------------------------------
  70          // Global MACROS
  71          //---------------------------------------------------------------------------------
  72          #define pulse_E();\
  73                  small_delay(1);\
  74                  LCD_CTRL_PORT = LCD_CTRL_PORT | E_MASK;\
  75                  small_delay(1);\
  76                  LCD_CTRL_PORT = LCD_CTRL_PORT & ~E_MASK;\
  77          
  78          //---------------------------------------------------------------------------------
  79          
  80          
  81          //-- LCD related functions ----------
  82          void lcd_init       (void);          // initialize the lcd to 8 bit mode
  83          void lcd_busy_wait  (void);          // wait until the lcd is no longer busy
  84          char putchar        (char c);        // replaces standard function and uses LCD
  85          void lcd_cmd        (char cmd);      // write a command to the lcd controller
  86          void lcd_home       (void);          // home curser
  87          void lcd_clear      (void);          // clear display
  88          void lcd_goto       (char addr);    // move to address addr
  89          void lcd_move_curser(char dist);     // moves curser forward or back by dist
  90          void lcd_curser     (bit on);        // 1 displays curser, 0 hides it
  91          void lcd_puts       (char string[]); // send string to lcd at current curser loc
  92          void small_delay    (char d);   // 8 bit,  about 0.34us per count @22.1MHz
  93          void large_delay    (char d);   // 16 bit, about 82us   per count @22.1MHz
  94          void huge_delay     (char d);   // 24 bit, about 22ms   per count @22.1MHz
  95          
  96          
  97          
  98          void Init_Clock(void)
  99          {
 100   1                      OSCXCN = 0x67; //-- 0110 0111b
 101   1                      //-- External Osc Freq Control Bits (XFCN2-0) set to 111
 102   1                      // because crystal frequency > 6.7 MHz
 103   1                      //-- Crystal Oscillator Mode (XOSCMD2-0) set to 110
 104   1                      //-- wait till XTLVLD pin is set
 105   1                      while ( !(OSCXCN & 0x80) );
 106   1                      OSCICN = 0x88; //-- 1000 1000b
 107   1                      //-- Bit 2 : Internal Osc. disabled (IOSCEN = 0)
 108   1                      //-- Bit 3 : Uses External Oscillator as System Clock
 109   1                      // (CLKSL = 1)
 110   1                      //-- Bit 7 : Missing Clock Detector Enabled (MSCLKE = 1)
 111   1      }
 112          
 113          void Init_Port(void) //-- Configures the Crossbar & GPIO ports
 114          {
 115   1                      XBR0 = 0x04; //-- Enable UART0
 116   1                      XBR1 = 0x04;
 117   1                      XBR1 |= 0x10;   //-- enable /INT1 (Pin P0.3)  //--New
C51 COMPILER V8.08   SERIAL_LAB_WITH_ENCODER                                               06/04/2009 22:04:59 PAGE 3   

 118   1                      XBR2 = 0x40; //-- Enable Crossbar and weak pull-ups
 119   1                      // (globally)
 120   1                      P0MDOUT |= 0x01; //-- Enable TX0 as a push-pull o/p
 121   1                      P1MDIN |= 0x08;         //-- Pin P0.3 is for input of Tacho Signal so write a '1' to it
 122   1                      P1MDOUT = 0xff; //-- Enable P1.6 (LED) as push-
 123   1                                                       // pull output
 124   1                                      
 125   1                                      //-- Port 7-4 I/O Lines
 126   1                      P74OUT = 0x48;                          // Output configuration for P4-7
 127   1                                                                              // (P7[0:3] Push Pull) - Control Lines for LCD
 128   1                                                                      // (P6 Open-Drain)- Data Lines for LCD
 129   1                                                                      // (P5[7:4] Push Pull) - 4 LEDs
 130   1                                                                      // (P5[3:0] Open Drain) - 4 Push-Button Switches (input)
 131   1                                                                      // (P4 Open Drain) - 8 DIP Switches (input)
 132   1      
 133   1      
 134   1                      P5 |= 0x0F;
 135   1      
 136   1      
 137   1              ES0 = 1;        //-- enable UART0 interrupt
 138   1              IT0 = 1;        //-- /INT0 is edge triggered
 139   1      //      IT1 = 1;        //-- /INT1 is edge triggered
 140   1              PT0 =1;         //-- High priority for Timer 0 (PWM generator)
 141   1              PT1 =1;         //-- High priority for Timer 1 (Tacho Counter)
 142   1              PT2 =1;
 143   1              EX0 = 1;        //-- enable external interrupt 0 (/INT0)
 144   1      //      EX1 = 1;        //-- enable external interrupt 1 (/INT1)
 145   1              
 146   1      
 147   1      }
 148          //--------------------------------------------------------------
 149          void Init_UART0(void)
 150          {
 151   1              //-- set up Timer 1 to generate the baude rate (115200) // for UART0
 152   1              CKCON |= 0x10; //-- T1M=1; Timer 1 uses the system clock
 153   1              // 22.11845 MHz
 154   1              TMOD = 0x20; //-- Timer 1 in Mode 2 (8-bit auto-
 155   1              // reload)
 156   1              TH1 = 0xF4; //-- Baud rate = 115200
 157   1              TR1 = 1; //-- start Timer 1 (TCON.6 = 1)
 158   1              T2CON &= 0xCF; //-- Timer 1 overflows used for receive & // transmit clock (RCLK0=0, TCLK0=0)
 159   1              //-- Set up the UART0
 160   1              PCON |= 0x80; //-- SMOD0=1 (UART0 baud rate divide-by-2
 161   1              // disabled)
 162   1              SCON0 = 0x50; //-- UART0 Mode 1, Logic level of stop
 163   1              
 164   1              // bit ignored and Receive enabled
 165   1              //-- enable UART0 interrupt
 166   1              IE |= 0x10;
 167   1              IP |= 0x10; //-- set to high priority level
 168   1              RI0= 0; //-- clear the receive interrupt flag;
 169   1      
 170   1              // ready to receive more
 171   1      }
 172          //--------------------------------------------------------------
 173          //-- Configure Timer3 to auto-reload and generate an interrupt 
 174          // at interval specified by <counts> using SYSCLK/12 as its
 175          // time base.
 176          void Init_Timer3 (unsigned int counts)
 177          {
 178   1                      TMR3CN = 0x00; //-- Stop Timer3; Clear TF3;
 179   1                                                 //-- use SYSCLK/12 as time base
C51 COMPILER V8.08   SERIAL_LAB_WITH_ENCODER                                               06/04/2009 22:04:59 PAGE 4   

 180   1                      TMR3RL = -counts; //-- Init reload values
 181   1                      TMR3 = 0xffff; //-- set to reload immediately
 182   1                      EIE2 |= 0x01; //-- enable Timer3 interrupts
 183   1                      TMR3CN |= 0x04; //-- start Timer3 by setting TR3
 184   1                      // (TMR3CN.2) to 1
 185   1      }
 186          
 187          //-- This routine changes the state of the LED whenever Timer3
 188          // overflows.
 189          void Timer3_ISR (void) interrupt 14
 190          {
 191   1                      TMR3CN &= ~(0x80); //-- clear TF3
 192   1                      LED_count++;
 193   1                      Tick_count++;
 194   1                      
 195   1                      
 196   1                              
 197   1                              
 198   1                              if ( (LED_count % 10) == 0) //-- do every 10th count
 199   1                              {
 200   2                                      if ( blink_speed==0)
 201   2                                      {
 202   3                                              LED=0;
 203   3                                      }
 204   2      
 205   2                                      else
 206   2                                      {
 207   3                                 
 208   3                                      LED = ~LED; //-- change state of LED
 209   3                                      LED_count = 0;
 210   3      
 211   3                                      }
 212   2                              }
 213   1                      
 214   1      }
 215          
 216          void Init_Timer0(unsigned char reload0)
 217          {
 218   1              CKCON = 0x00;
 219   1              TMOD = 0x32;
 220   1              TH0 = reload0;
 221   1              TL0 = TH0;
 222   1              TCON  = 0x14;           //-- Enable Timer0 Interrupt    
 223   1              IE    = 0x06;           //-- Start Timer0
 224   1      }
 225          
 226          void Timer0_ISR(void) interrupt 1
 227          {
 228   1              TF0 = 0;
 229   1              encoder_count++;
 230   1      }
 231          
 232          void Init_ADC0(void)
 233          {
 234   1              
 235   1          REF0CN = 0x03;      // Vref setup
 236   1          ADC0CF = 0x80;      // SAR0 Conversion, clock = 941 kHz approx, Gain = 1
 237   1      
 238   1          AMX0CF = 0x00;      // 8 single-ended inputs
 239   1          AMX0SL = 0x00;      // select AIN0 input
 240   1          ADC0CN = 0x80;      // enable ADC0, continuous tracking mode, 
 241   1                                              // conversion initiated on every write of "1" to AD0BUSY
C51 COMPILER V8.08   SERIAL_LAB_WITH_ENCODER                                               06/04/2009 22:04:59 PAGE 5   

 242   1                                              // and right justify data
 243   1      
 244   1          EIE2 = 0x02;        // enable ADC0 end of conversion interrupts
 245   1      
 246   1      }
 247          
 248          
 249          void ADC0_ISR(void) interrupt 15
 250          {
 251   1        
 252   1          ADC0CN = 0x91;      // enable ADC0, continuous tracking mode, ADC0 conversion is in progress 
 253   1                                              // conversion initiated on every write of "1" to AD0BUSY
 254   1                                              // and left justify data
 255   1      
 256   1               //message = ADC0H;     // calc the ref_speed by using ADCO value
 257   1               //message = message >>1; //make message to between 0 and 127
 258   1      
 259   1      
 260   1      }
 261          
 262          
 263          //--------------------------------------------------------------
 264          void UART0_ISR(void) interrupt 4
 265          {
 266   1              
 267   1              time_in_sec=1/115000;
 268   1      
 269   1                      //-- pending flags RI0 (SCON0.0) and TI0(SCON0.1)
 270   1                      if  ( RI0 == 1) //-- interrupt caused by received byte
 271   1                      {
 272   2      
 273   2                              received_byte = SBUF0; //-- read the input buffer
 274   2                              RI0 = 0; //-- clear the flag
 275   2                              new_cmd_received=1;
 276   2              
 277   2                      }
 278   1            
 279   1      
 280   1                   //START: buttons 1 and 2 together
 281   1      
 282   1                                if  ( P5 == 0x03) 
 283   1                                        {
 284   2                                            
 285   2                              lcd_clear();
 286   2                                       //     lcd_goto(0x00) ;   //-- go to first Row
 287   2                                                  printf("   Start   ");
 288   2                                                      //lcd_goto(0x40);   //-- go to Second Row
 289   2                                                      printf("  but 2 & 3:  ");
 290   2      
 291   2      
 292   2                                                 //start
 293   2                                                      command = 0xCC; // DEC=204
 294   2                                        }
 295   1      
 296   1              
 297   1                       //STALL: buttons 3 and 4 together
 298   1      
 299   1                if ( (P5 == 0x0C)) 
 300   1                                        {
 301   2                                            
 302   2                              lcd_clear();
 303   2                                       //     lcd_goto(0x00) ;   //-- go to first Row
C51 COMPILER V8.08   SERIAL_LAB_WITH_ENCODER                                               06/04/2009 22:04:59 PAGE 6   

 304   2                                                  printf("   Stall   ");
 305   2                                              //      lcd_goto(0x40);   //-- go to Second Row
 306   2                                                      printf(" but 3 & 4   ");
 307   2      
 308   2                                                      P5 &= 0x0F;
 309   2      
 310   2                                                 //stall
 311   2                                                      command = 0xDD;
 312   2                                        }
 313   1      
 314   1                       random = rand();
 315   1                       
 316   1                       random = random >> 8;
 317   1      
 318   1             //set output buffer
 319   1                  outBuffer[0] = command;
 320   1                      
 321   1                      outBuffer[1] = P2;
 322   1                              outBuffer[2] = message;
 323   1                              outBuffer[3] = received_byte;
 324   1              
 325   1                      
 326   1                      for (count = 0; count <4 ; count++)
 327   1                               {
 328   2      
 329   2                                while(        TI0 ==0)
 330   2      
 331   2                                   {
 332   3                                                SBUF0 = outBuffer[count]; //-- send the sent_byte to output
 333   3                                                small_delay(100);
 334   3                                        
 335   3                                        }  
 336   2                                       
 337   2                 
 338   2                              TI0 = 0;
 339   2                         
 340   2                       }//for 
 341   1       
 342   1      
 343   1      }//UART0_ISR
 344          
 345          /////////////////////////////////////////////////////////////////////////
 346          
 347          void INT1_ISR(void) interrupt 2 
 348          {
 349   1              TF0 = 1;
 350   1              if(encoder_count > 0)                           //-- Leave Actual Speed Display in 
 351   1                                                                                      //-- Current State if Tacho has not 
 352   1                                                                                      //-- Counted (Removes divide by 0 case)
 353   1              {
 354   2                      Shaft_Speed = 310/encoder_count;        //-- Changed from 3000000 as proportionality
 355   2                                                                                              //-- constant K is 9672 times smaller due to
 356   2                                                                                              //-- 312 pulses from encoder per shaft
 357   2                                                                                              //-- revolution and 1:31 gearing
 358   2                      
 359   2                      if(Shaft_Speed > 4095)
 360   2                      {
 361   3                              Shaft_Speed = 0;
 362   3                      }
 363   2                      
 364   2                      else
 365   2                      {
C51 COMPILER V8.08   SERIAL_LAB_WITH_ENCODER                                               06/04/2009 22:04:59 PAGE 7   

 366   3                              actual_speed = Shaft_Speed;             // Display Actual Speed
 367   3                      }
 368   2              }
 369   1              
 370   1              encoder_count = 0;                              // Reset Tacho Counter
 371   1      }
 372          
 373          
 374          
 375          //--------------------------------------------------------------
 376          void main(void)
 377          {
 378   1                      blink_speed = 0;
 379   1                      encoder_count = 1;
 380   1                      actual_speed = 0;
 381   1                      new_cmd_received = 0; 
 382   1                      port5=0;
 383   1                      command = 0;
 384   1                      message = 0;
 385   1                      i = 0;
 386   1                  count = 0;
 387   1                      random =0; 
 388   1      
 389   1              P5 = 0x0F;                      //-- Turn the 4 green LEDs off
 390   1                      P1 = 0x00;
 391   1      
 392   1                      LED_count = 0;
 393   1                      LED = 0;
 394   1                      DIR = 0;
 395   1                      EA = 0; //-- disable global interrupts
 396   1                      WDTCN = 0xDE; //-- disable watchdog timer
 397   1                      WDTCN = 0xAD;
 398   1                      Init_Clock();
 399   1                      lcd_init();
 400   1                  lcd_curser(0); 
 401   1                      Init_Port();
 402   1                      Init_ADC0();
 403   1                      Init_Timer0(219);
 404   1                      Init_UART0();
 405   1                      Init_Timer3(39);
 406   1                      AD0BUSY = 1;    // write 1 to ADC0BUSY and start ADC0 conversion 
 407   1                      EA = 1; //-- enable global interrupts
 408   1                              
 409   1                      
 410   1      
 411   1                      while(1) //-- go on forever
 412   1                      {
 413   2                  lcd_goto(0x80);   //-- go to Second Row
 414   2                              
 415   2                              
 416   2                              printf("Speed(RPM):%5u", actual_speed);
 417   2                              command=1; // send code 1 to pc
 418   2                              message = RPM; // send message to pc that the RPM is...
 419   2      
 420   2                              if( i == 3000)
 421   2                              {
 422   3                                      i = -1;
 423   3                                      RI0 = 1;
 424   3                              
 425   3                              }
 426   2                              //else
 427   2                           //  RI0 == 0;
C51 COMPILER V8.08   SERIAL_LAB_WITH_ENCODER                                               06/04/2009 22:04:59 PAGE 8   

 428   2      
 429   2                      
 430   2                      if ( blink_speed==0)
 431   2                              {
 432   3                                      LED=0;
 433   3                              }
 434   2      
 435   2                 if (new_cmd_received == 1)
 436   2                     {
 437   3                         
 438   3      
 439   3              
 440   3                          switch (received_byte)
 441   3                                      {
 442   4                                      case 0:
 443   4      
 444   4                                              lcd_clear();
 445   4                                      //-- Display
 446   4                                              lcd_goto(0x00) ;   //-- go to first Row
 447   4                                          printf("  ");
 448   4                                              huge_delay(20);
 449   4                                              blink_speed = 0;
 450   4                                              DIR=0;
 451   4                                              break; 
 452   4      
 453   4                                      case 1: 
 454   4      
 455   4                                          lcd_clear();
 456   4                                              //-- Display
 457   4                                              lcd_goto(0x00) ;   //-- go to first Row
 458   4                                          printf("  Left Slow"  );
 459   4                                              huge_delay(20);
 460   4                                              blink_speed = 10000;
 461   4                                              break; // slow
 462   4      
 463   4                                      case 2: 
 464   4      
 465   4                                               lcd_clear();
 466   4                                              //-- Display
 467   4                                              lcd_goto(0x00) ;   //-- go to first Row
 468   4                                          printf("  Left Medium " );
 469   4                                              huge_delay(20);
 470   4                                              blink_speed = 10; 
 471   4                                              break; // medium
 472   4      
 473   4                                      case 3:
 474   4      
 475   4                                              lcd_clear();
 476   4                                      //-- Display
 477   4                                              lcd_goto(0x00) ;   //-- go to first Row
 478   4                                          printf("  Left Fast");
 479   4                                              huge_delay(20);
 480   4                                              blink_speed = 50;
 481   4                                              break; // fast
 482   4      
 483   4                                      case 4: 
 484   4      
 485   4                                          lcd_clear();
 486   4                                              //-- Display
 487   4                                              lcd_goto(0x00) ;   //-- go to first Row
 488   4                                          printf("  Right Slow"  );
 489   4                                              huge_delay(20);
C51 COMPILER V8.08   SERIAL_LAB_WITH_ENCODER                                               06/04/2009 22:04:59 PAGE 9   

 490   4                                              blink_speed = 100000;
 491   4                                              break; // slow
 492   4      
 493   4                                      case 5: 
 494   4      
 495   4                                               lcd_clear();
 496   4                                              //-- Display
 497   4                                              lcd_goto(0x00) ;   //-- go to first Row
 498   4                                          printf("  Right Medium " );
 499   4                                              huge_delay(20);
 500   4                                              blink_speed = 10; 
 501   4                                              break; // medium
 502   4      
 503   4                                      case 6:
 504   4      
 505   4                                              lcd_clear();
 506   4                                      //-- Display
 507   4                                              lcd_goto(0x00) ;   //-- go to first Row
 508   4                                          printf("  Right Fast");
 509   4                                              huge_delay(20);
 510   4                                              blink_speed = 50;
 511   4                                              break; // fast
 512   4      
 513   4                                      case 7:
 514   4      
 515   4                                              lcd_clear();
 516   4                                      //-- Display
 517   4                                              lcd_goto(0x00) ;   //-- go to first Row
 518   4                                          printf("  Stop");
 519   4                                              huge_delay(20);
 520   4                                              blink_speed = 0;
 521   4                                              break; // 
 522   4      
 523   4                                      case 8:
 524   4      
 525   4                                              DIR=1;
 526   4                                              break; // 
 527   4      
 528   4                                      case 9:
 529   4      
 530   4                                              DIR=0;
 531   4                                              break; // fast
 532   4                                      
 533   4                                      default : blink_speed = 0; break;
 534   4                              }
 535   3      
 536   3                              
 537   3                              EA = 1; //-- enable interrupts
 538   3                              new_cmd_received = 0;
 539   3      
 540   3      
 541   3                      }//if
 542   2      
 543   2                   i++;
 544   2                               
 545   2              }//while
 546   1      
 547   1      }//main
 548          
 549          
 550          
 551          //------------------- LCD functions -----------------------------------------------
C51 COMPILER V8.08   SERIAL_LAB_WITH_ENCODER                                               06/04/2009 22:04:59 PAGE 10  

 552          #pragma OPTIMIZE (7)
 553          void lcd_init(void)
 554          {
 555   1              LCD_CTRL_PORT = LCD_CTRL_PORT & ~RS_MASK;       // RS = 0
 556   1              LCD_CTRL_PORT = LCD_CTRL_PORT & ~RW_MASK;       // RW = 0
 557   1              LCD_CTRL_PORT = LCD_CTRL_PORT & ~E_MASK;        //  E = 0
 558   1              large_delay(200);                                 // 16ms delay
 559   1      
 560   1              LCD_DAT_PORT = 0x38;                      // set 8-bit mode
 561   1              pulse_E();
 562   1              large_delay(50);                                  // 4.1ms delay
 563   1      
 564   1              LCD_DAT_PORT = 0x38;                      // set 8-bit mode
 565   1              pulse_E();
 566   1              large_delay(2);                           // 1.5ms delay
 567   1      
 568   1              LCD_DAT_PORT = 0x38;                      // set 8-bit mode
 569   1              pulse_E();
 570   1              large_delay(2);                           // 1.5ms delay
 571   1      
 572   1              lcd_cmd(0x06);                                    // curser moves right
 573   1              lcd_cmd(0x01);                                    // clear display
 574   1              lcd_cmd(0x0E);                                    // display and curser on
 575   1      }
 576          
 577          #pragma OPTIMIZE (9)
 578          
 579          
 580          
 581          //---------------------------------------------------------------------------------
 582          // lcd_busy_wait
 583          //---------------------------------------------------------------------------------
 584          //
 585          // wait for the busy bit to drop
 586          //
 587          void lcd_busy_wait(void)
 588          {
 589   1              LCD_DAT_PORT = 0xFF;
 590   1              LCD_CTRL_PORT = LCD_CTRL_PORT & ~RS_MASK;       // RS = 0
 591   1              LCD_CTRL_PORT = LCD_CTRL_PORT | RW_MASK;        // RW = 1
 592   1              small_delay(1);
 593   1              LCD_CTRL_PORT = LCD_CTRL_PORT | E_MASK; //  E = 1
 594   1      //      TB_GREEN_LED = 1;
 595   1              do
 596   1              {                                                                 // wait for busy flag to drop
 597   2                      small_delay(1);
 598   2              } while ((LCD_DAT_PORT & 0x80) != 0);
 599   1      //      TB_GREEN_LED = 0;
 600   1      }
 601          
 602          
 603          //---------------------------------------------------------------------------------
 604          // lcd_dat (putchar)
 605          //---------------------------------------------------------------------------------
 606          //
 607          // write a character to the lcd screen
 608          //
 609          char putchar(char dat)
 610          {
 611   1              lcd_busy_wait();
 612   1              LCD_CTRL_PORT = LCD_CTRL_PORT | RS_MASK;        // RS = 1
 613   1              LCD_CTRL_PORT = LCD_CTRL_PORT & ~RW_MASK;       // RW = 0
C51 COMPILER V8.08   SERIAL_LAB_WITH_ENCODER                                               06/04/2009 22:04:59 PAGE 11  

 614   1              LCD_DAT_PORT = dat;
 615   1              pulse_E();
 616   1              return 1;
 617   1      }
 618          
 619          
 620          //---------------------------------------------------------------------------------
 621          // lcd_cmd
 622          //---------------------------------------------------------------------------------
 623          //
 624          // write a command to the lcd controller
 625          //
 626          void lcd_cmd(char cmd)
 627          {
 628   1              lcd_busy_wait();
 629   1              LCD_CTRL_PORT = LCD_CTRL_PORT & ~RS_MASK;       // RS = 0
 630   1              LCD_CTRL_PORT = LCD_CTRL_PORT & ~RW_MASK;       // RW = 0
 631   1              LCD_DAT_PORT = cmd;
 632   1              pulse_E();
 633   1      
 634   1      }
 635          
 636          
 637          //---------------------------------------------------------------------------------
 638          // lcd_goto
 639          //---------------------------------------------------------------------------------
 640          //
 641          // change the text entry point
 642          //
 643          void lcd_goto(char addr)
 644          {
 645   1              lcd_cmd(addr | 0x80);
 646   1      }
 647          
 648          //---------------------------------------------------------------------------------
 649          // lcd_clear
 650          //---------------------------------------------------------------------------------
 651          void lcd_clear(void)
 652          {
 653   1              lcd_cmd(0x01);  //-- clear LCD display
 654   1              lcd_cmd(0x80);  //-- curser go to 0x00
 655   1      }
 656          
 657          //---------------------------------------------------------------------------------
 658          // lcd_curser
 659          //---------------------------------------------------------------------------------
 660          void lcd_curser(bit on)        // 1 displays curser, 0 hides it
 661          {
 662   1              if (on)
 663   1                      lcd_cmd(0x0E);  
 664   1              else
 665   1                      lcd_cmd(0x0C);
 666   1      }
 667          
 668          
 669          
 670          //---------------------------------------------------------------------------------
 671          // delay routines
 672          //---------------------------------------------------------------------------------
 673          
 674          void small_delay(char d)
 675          {
C51 COMPILER V8.08   SERIAL_LAB_WITH_ENCODER                                               06/04/2009 22:04:59 PAGE 12  

 676   1              while (d--);
 677   1      }
 678          
 679          
 680          void large_delay(char d)
 681          {
 682   1              while (d--)
 683   1                      small_delay(255);
 684   1      }
 685          
 686          
 687          void huge_delay(char d)
 688          {
 689   1              while (d--)
 690   1                      large_delay(255);
 691   1      }
 692          
 693          //------------------- End Of File ---------------------------------------------------


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1246    ----
   CONSTANT SIZE    =    159    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     50       2
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       1
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
